# 이벤트 버블링(Event Bubbling), 이벤트 캡처링(Event Capturing)에 대해서 설명하세요.
* 이벤트 버블링
-> 특정 화면 요소에서 이벤트가 발생했을 때 더 상위 요소들로 전달되어 가는 특성을 의미함
* 이벤트 캡처링
-> 이벤트 버블링과 반대로 상위 요소에서 하위 요소로 탐색하여 이벤트를 전파하는 방식

# 이벤트 버블링을 막을 수 있는 방법은?
이벤트 버블링을 막기 위해서는 이벤트 객체인 메소드인 `event.stopPropagation()`을 사용하면 된다.

# event delegation에 대해서 설명
* 이벤트 위임은 상위노드에서 하위노드의 이벤트를 제어하고 싶을 때 쓰는 방식
* 동적인 요소들에 대한 처리가 수월함
* 이벤트 핸들러를 더 적게 등록해주기 때문에 메모리도 절약할 수 있음
* to do list에서 오늘의 할일을 추가하고, 그 추가된 항목의 일을 완료했다면
* 완료했다는 의미로 밑줄을 그어야 한다.
* 이 때 이벤트 위임을 활용하여 li 태그의 추가된 리스트를 통제할 수 있는 ul 태그에 이벤트 리스너를 연결
* 그 후 하위에서 발생하는 이벤트를 감지 시켜주도록 사용할 수 있음

# this는 자바스크립트에서 어떻게 동작하는가?
* this는 자바스크립트 런타임 시 바인딩이 이루어지는 실행컨텍스트 중 하나로, 
* 함수가 동작할 때 해당 this가 무엇인지 알 수 있게 됨
* 때로는 복잡한 코드에서 암시적인 바인딩에 의해 혼란스러운 경우가 있는데, 
* 이러한 문제를 call이나 apply같은 내장 유틸리티를 사용하여 명시적으로 바인딩 해줌

# property 기반의 상속은 어떻게 하는지 설명해주세요.
* 자바스크립트 객체에는 Prototype이라는 내부 프로퍼티가 있고, 이는 다른 객체를 참조할 때 사용한다.
* 부모 프로토타입을 create()나 setPropertyOf()메소드를 사용하여 자식 프로토 타입과 연결함

# null과 undefined의 차이점은?
둘은 값이 없다는 의미하지만, null의 경우에는 값이 비어있음을 값으로 등록한 것이며, undefined는 초기값으로 할당되어진 것이다.

# Ajax란?
AJAX는 비동기 자바스크립트 XML의 약자로써 클라이언트와 서버가 XML의 데이터를 주고 받는 기술이다.
기존에는 클라이언트에서 서버로 요청을 보내고 화면을 새로 갱신해야했기 때문에 많은 리소스가 필요했다. 이러한 이유로 데이터가 바뀌는 영역만 일부 갱신할 수 있도록 AJAX는 XMLHttpRequest 객체를 서버에 요청한다. 이로 인해 자원과 시간을 많이 아낄 수 있다.

# callback, Promise, async/await의 차이점
* 이 세개의 함수는 비동기를 위한 함수로 맨 먼저 callback이 만들어지게 됨.
* callback은 함수의 처리 순서를 보장하는 과정에서 중첩해서 사용하게 되고,
* 이를 계속해서 사용하다 보니 콜백 지옥 현상이 발생하게 됨
* 콜백 지옥 현상으로 인해 가독성과 유지보수가 떨어지게 되고, 

* 그 이후로 Promise가 탄생하게 되었음
* Promise는 비동기 연산이 종료된 이후에 에러를 처리할 수 있도록 처리기를 연결하는 역할의 객체임
* 그 Promise 객체로 인해 성공, 실패, 에러처리 로직을 처리하기에 수월해지게 됨

* Async/await는 비동기 코드를 동기식으로 표현하는 더 나은 방법으로, 이 둘은 같이 있어야 제대로 동작이 가능함
* Async함수는 Promise 객체를 통해 비동기적으로 처리된 내용을 동기적인 코드 진행 순서로 보여주는 역할을 함
* await는 Promise 객체를 받아서 처리하고, 만약 비동기함수가 아닌 동기적 함수라면 리턴값을 그대로 받음

# let, var, const의 차이점
* 기존의 자바스크립트 변수선언은 var만 가능했지만 var의 문제점으로 인해 let과 const가 탄생하게 되었다.
* 우선 var는 재선언이 가능하다. 
* 즉, dog라는 변수에 `var dog = '바둑이`를 코드를 통해 값이 할당되었다면 바둑이에 관한 함수가 쓰여질 경우 이 때 dog라는 변수의 값이 바뀌지 않도록 주의해야한다.
* 하지만 재선언이 가능하기 때문에 값이 백구로 변경이 되어도 오류가 발생하지 않는다. 
* 이러한 문제점이 발생하게 되면서 재할당이 가능한 let과 재선언과 재할당이 가능하지 않은 const가 만들어지게 되었다.
* let을 사용하게 되면 앞서 말했던 예시에서 dog라는 변수의 값을 변경시키기 위해서는 `dog = '백구'`라는 코드로 변경할 수 있기 때문에
* 해당 값이 먼저 선언되어져 있음을 알 수 있다. 
* 이제 const의 경우에는 상수나 변하지 않은 값을 할당하고 싶을 때 사용되는 변수임
* 이외에도 var는 1) 선언 + 초기화 한번에 이뤄나서 2) 할당 전에 값을 출력해도 undefined가 찍히게 됨
* 반면에 let은 1) 선언 2) 초기화 3) 할당이 3번에 일어나서 값을 선언하고 초기화 전에 출력하면 reference Error가 나옴
* 마지막인 const는 1) 선언 + 초기화 + 할당이 한번에 일어나기 때문에 syntax Error가 나오게 된다.

# event loop란?
자바스크립트 엔진이 call stack과 callback queue의 상태를 체크하여 call stack이 빈 상태가 되면, callback queue에 있던 첫번째 콜백을 call stack으로 밀어넣는 것을 의미함

# Javascript Scope Chaining?
실행 컨텍스트 내에서 변수를 탐색할 때 중복된 변수가 있더라도 먼저 탐색된 변수를 우선적으로 실행시키는 방식

